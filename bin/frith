#!/usr/bin/perl
my $program = 'frith';
my $version = '0.1';

########################################################################
#
# frith
#
########################################################################


# core libs
use strict;
use warnings;
use Sys::Hostname;
use File::Path qw/ make_path /;
use File::Temp qw/ tempfile tempdir /;
use File::Spec::Functions qw(catfile);
use Time::Piece;
#use IPC::Open2;

# socks wrapper, default to using tor (we can disable this later)
# note that only those modules use-d below this will be wrapped
# we have to package this ourselves from cpan
use IO::Socket::Socks::Wrapper { 
	ProxyAddr => 'localhost', 
	ProxyPort => 9050 
};								# libio-socket-socks-wrapper-perl

# extra debian libs
use File::HomeDir qw(home);		# libfile-homedir-perl
use DateTime;					# libdatetime-perl
use Try::Tiny;                  # libtry-tiny-perl
use Email::Valid; 				# libemail-valid-perl
use Email::Sender::Transport::SMTP;  #libemail-sender-perl
use Email::Sender::Simple;      # ditto
use Email::MIME;                # libemail-mime-perl
use Term::ReadKey; 				# libterm-readkey-perl
use Switch;                     # libswitch-perl
use Expect;                     # libexpect-perl

# other cpan libs (we'll have to package these ourselves too)
# the rpm/alien version of Term::Choose is installed in a stupid place
use lib "/usr/lib/perl5/vendor_perl/5.22.0";
use Term::Choose qw(choose); 	# cpan

# debugging only - not in tails
#use Data::Dumper;

# also requires:
# tar

# GnuPG::Interface does not do what we want. Will have to implement our
# own harnesses for key management

# Libraries preinstalled in tails that we may find useful in future:
#
# tails::perl5lib
# ipc::run 				to replace open("|")
# ipc::system::simple 	to replace system()
# archive::tar::wrapper to replace system("tar")
# file::copy::recursive to replace system("cp")

# Other debian libraries perhaps useful in future:
#
# term::query 			to replace readkey, built in validation
# term::readpassword 	to replace readkey for passwords


##### GPG enumeration values

my $reason_none = 0;
my $reason_compromised = 1;
my $reason_superseded = 2;
my $reason_unused = 3;
my $reason_invalid = 4;


##### Various defaults

my $default_expiry = '2y';
my $default_bits = 4096;

my $default_subkeys_dir = catfile(home(),'.ssh');
my $default_subkeys_suffix = '_subkeys.gpg';
my $default_ssh_key_suffix = '_id_rsa';
my $default_ssh_pubkey_suffix = '_id_rsa.pub';

my $default_backup_dir = home();
my $default_backup_file = 'gnupg.tar';

my $gpg_location = catfile(home(),'.gnupg');

my $default_gpg_options = "--pinentry-mode loopback --keyid-format 0xlong --with-fingerprint --status-fd 2";

my $skel_location = '/var/cache/frith';

my %usage_map = ( 's'=>'sign', 'e'=>'encrypt', 'a'=>'auth' );

###############
# Houskeeping #
###############

END {
	# clean up our own mess
	ReadMode(0);
	system('stty sane');
}

my $menu = new Term::Choose();


#############################
# Process command line args #
#############################

my %CMD_OPTIONS;

sub parse_options {
  while($ARGV[0] and $ARGV[0]=~/^--/) {
	my $option = shift(@ARGV);
	my $value = 1;
	$option =~ s/^--//;
	if($option =~ /=/) {
		($option, $value) = split('=', $option);
	}
	$CMD_OPTIONS{$option} = $value;
  }
}

sub option_help {
	print qq[${program} takes the following options:

--help          This help
--debug         Mild debugging info, screen is never cleared
--debugpipe     Verbatim gnupg command output, can be verbose
--nopublish     Suppress publishing keys, for safe testing

];
}

sub get_date {
	return localtime->strftime('%Y-%m-%d');
}


#################### Logging routines #######################


sub debug {
    return 0 unless $CMD_OPTIONS{'debug'};
    my $message = shift;
    print STDERR "DEBUG: $message\n";
}

sub debugpipe {
    return 0 unless $CMD_OPTIONS{'debugpipe'};
    my $message = shift;
    print STDERR "DEBUGPIPE: $message";
}


#################### Detection routines #######################

# Let's probe to see what Tails features we can detect.
# Otherwise we'll assume we're running on a standard box.

my $using_tails = 0;
my $using_tails_persistence = 0;
my $using_tails_persistence_gpg = 0;
my $tails_partition = '';

sub tails_test {
	# detect tails configuration
	if(-d '/home/amnesia' and hostname eq 'amnesia') {
		$using_tails = 1;
		if(-e '/dev/mapper/TailsData_unlocked') {
			$using_tails_persistence = 1;
			if(-d '/live/persistence/TailsData_unlocked/gnupg') {
				$using_tails_persistence_gpg = 1;
			}
		}
		open(my $pipe, '-|', 'mount')
            or die "failed to check mounts\n";
		while(<$pipe>) {
			if(m!^(\S+) on /lib/live/mount/medium type vfat!) {
				$tails_partition = $1;
				last;
			}
		}
		debug "detected \$tails_partition = $tails_partition";
	}
}

sub first_time {
	my $num_keys = 0;
	open(my $pipe, '-|', "gpg $default_gpg_options --with-colons --list-secret-keys 2>/dev/null")
		or die "failed to create gpg process\n";
	while(<$pipe>) {
		debugpipe($_);
		$num_keys ++ if(/^sec:/);
	}
	close($pipe);
	&notify("Primary keys found: $num_keys");
	return ! $num_keys;
}

my $fresh_smartcard = 0;

sub detect_smartcard {
	my $success = 0;
	my $sigs = 0;
	$fresh_smartcard = 0;

	# if we use --batch, then it doesn't prompt to insert a card
	# that's what we want, as we want to detect the card and handle
	# such cases ourselves
	open(my $pipe, '-|', "gpg $default_gpg_options --card-status 2>/dev/null")
		or return 0;
	while(<$pipe>) {
        debugpipe($_);
		chop;
		if(/^Name of cardholder: \[not set\]$/) {
			$success = 1;
			$fresh_smartcard = 1;
			debug "Unset name";
		}
		if(s/^Signature counter : (\d+)$/$1/) {
			$success = 1;
			$sigs = $_;
			# a card cannot be fresh if it has sigs
			$fresh_smartcard = 0 if $sigs > 0;
			last;
		}
	}
	close($pipe);

	debug "Card $success: Signature count $sigs: Freshness $fresh_smartcard";
	return $success;
}


#################################################################
###################### Menu structure ###########################
#################################################################


# Define labels. We need these for comparisons because the menu return
# values are the full text of the label. (This will be a i18n nightmare)
# Beware some labels may appear in multiple menus.

# Top menu
my $LA_certify = 'Certify or decertify another person';
my $LA_generate = 'Generate new key';
my $LA_backup = 'Backup and restore';
my $LA_publish = 'Publish your key';
my $LA_subkeys = 'Export your private subkeys';
my $LA_smartcard = 'Smartcard management';
my $LA_modify = 'Modify your key';
my $LA_help = 'Help';

# Sub menus
my $LA_cert_scan = 'Certify using a QR code';
my $LA_cert_manual = 'Certify by fingerprint';
my $LA_decert_manual = 'Decertify a key';

my $LA_usedefaults = 'Generate new key with recommended settings';
my $LA_gen_advanced = 'Advanced key generation';

my $LA_clone_to_tails = 'Clone to another Tails disk';
my $LA_backup_to_file = 'Back up to file';
my $LA_restore_from_file = 'Restore from file';

my $LA_publish_to_keyserver = 'Publish your key to the keyserver(s)';
my $LA_publish_to_wks = 'Publish your key to your Web Key Directory';
my $LA_send_by_email = 'Send your key by email';
my $LA_save_to_file = 'Save your key to a file';

my $LA_subkeys_to_file = 'Export private subkeys to file';
my $LA_subkeys_to_smartcard = 'Export private subkeys to smartcard';

my $LA_sc_status = 'Print smartcard status';
my $LA_init_smartcard = 'Initialise smartcard';
my $LA_sc_factory_reset = 'Reset a v2.x smartcard to factory default';
my $LA_smartcard_advanced = 'Advanced smartcard management';
my $LA_sc_pin = 'Change smartcard PIN';
my $LA_sc_name = 'Change smartcard owner';
my $LA_sc_lang = 'Change smartcard language';
my $LA_sc_keylocation = 'Change smartcard public key location';

my $LA_new_uid = 'Add a new UID to a primary key';
my $LA_revoke_uid = 'Revoke a UID from a primary key';
my $LA_key_passphrase = 'Change key passphrase';
my $LA_expire_key = 'Change the expiry on a primary key';
my $LA_new_subkey = 'Create a new subkey';
my $LA_expire_subkey = 'Change the expiry on a subkey';
my $LA_revoke_subkey = 'Revoke a subkey';
my $LA_revoke_primary = 'Revoke my primary key';
my $LA_key_advanced = 'Advanced key management';

my $LA_getting_started = 'Getting started wizard';
my $LA_manual = 'Operations manual';


# Arrange our action labels into a menu structure.

my @CH_top = (
    $LA_certify,
    $LA_generate,
    $LA_backup,
    $LA_publish,
    $LA_subkeys,
    $LA_smartcard,
    $LA_modify,
    $LA_help,
);

my @CH_certify = (
    $LA_cert_scan,
    $LA_cert_manual,
#    $LA_decert_manual, # beware that publishing revocations to Hagrid is futile
);
my @CH_generate = (
	$LA_usedefaults,
	$LA_gen_advanced,
);
my @CH_backup = (
	$LA_clone_to_tails,
	$LA_backup_to_file,
	$LA_restore_from_file,
);
my @CH_backup_no_tails = (
	$LA_backup_to_file,
	$LA_restore_from_file,
);
my @CH_publish = (
    $LA_publish_to_keyserver,
    $LA_publish_to_wks,
    $LA_send_by_email,
    $LA_save_to_file,
);
my @CH_subkeys = (
	$LA_subkeys_to_smartcard,
	$LA_subkeys_to_file,
);
my @CH_smartcard = (
	$LA_subkeys_to_smartcard,
	$LA_sc_status,
	$LA_init_smartcard,
	$LA_sc_pin,
#	$LA_sc_name,		# not implemented
#	$LA_sc_lang,		# not implemented
#	$LA_sc_keylocation,	# not implemented
	$LA_sc_factory_reset,
	$LA_smartcard_advanced,
);
my @CH_modify = (
	$LA_key_passphrase,
	$LA_new_uid,
	$LA_revoke_uid,
	$LA_expire_key,
	$LA_new_subkey,
	$LA_expire_subkey,
	$LA_revoke_subkey,
	$LA_revoke_primary,
	$LA_key_advanced,
);
my @CH_help = (
	$LA_manual,
	$LA_getting_started,
);

my @CH_getting_started = (
	$LA_usedefaults,
	$LA_restore_from_file,
);


# Now provide an eval method for actions. Define this above label actions
# because some may want to use this hook functionality.
# Note that identical labels will always trigger identical operations
# when using the actionmap.

my %actionmap;
sub evaluate_choice {
	my $choice = shift;
	debug "You have chosen ${choice}";
	&{$actionmap{$choice}}();
}


# Submenu logic. Define this above label actions because some may want to
# create a submenu.

sub make_submenu() {
	my $heading = shift;
	my $response = $menu->choose(
		[@_, undef],
		{
			prompt => "${heading}\n\n",
			undef  => 'Back',
			layout => 3,
		}
	);
	return $response;
}

#############################################################
###################### UI tools #############################
#############################################################

# Tools to prompt the user with differing levels of urgency
# Most of these use Term::Choose

sub make_confirm() {
	my $heading = shift;
	my $response = $menu->choose(
		[undef, 'Yes, I am really really sure'],
		{
			prompt => "Are you really really sure you want to ${heading}?\n\n",
			undef  => 'On second thoughts, no',
			layout => 3,
		}
	);
	return $response;
}

sub make_yes() {
	my $heading = shift;
	my $response = $menu->choose(
		['Yes', undef],
		{
			prompt => "I am about to ${heading}. Continue?\n\n",
			undef  => 'Cancel',
			layout => 3,
		}
	);
	return $response;
}

sub make_pause() {
	my $response = $menu->choose(
		['Continue', undef],
		{
			prompt => "\n",
			undef  => 'Go back',
			layout => 3,
		}
	);
	return $response;
}

sub make_warned() {
	my $response = $menu->choose(
		['Run away! Run away!', undef],
		{
			prompt => "CONSIDER YOURSELF WARNED\n\n",
			undef  => 'Yes, I consider myself warned',
			layout => 3,
		}
	);
	# negate the return value, as we want undef --> true
	return ! $response;
}

sub prompt_insert_sc() {
	my $response = $menu->choose(
		['OK', undef],
		{
			prompt => "Please insert a PGP smartcard\n\n",
			undef  => 'Continue without smartcard',
			layout => 3,
		}
	);
	return $response;
}

sub prompt_overwrite_old_sc() {
	my $response = $menu->choose(
		[undef, 'Overwrite smartcard'],
		{
			prompt => "PGP Smartcard appears to contain user data\n\n",
			undef  => 'Do not use smartcard',
			layout => 3,
		}
	);
	return $response;
}


# Tools to get sanitized user input
# Most of these use Term::ReadKey

sub user_input() {
	# print a prompt
	print shift;
	my $input=ReadLine(0);
	$input =~ s/[\n\r\f\t]//g;
	return $input;
}

sub secure_input() {
	my $prompt = shift;
	ReadMode('noecho');
	print $prompt;
	my $input=ReadLine(0);
	$input =~ s/[\n\r\f\t]//g;
	print "\n";
	ReadMode('restore');
	return $input;
}

sub alnum_filter() {
	my $input = shift;
	$input =~ s/[^[:alnum:]]//g;
	return $input;
}

sub id_filter() {
	my $input = shift;
	$input =~ s/ //g;
	$input =~ s/([[:digit:]]+\/)?0x//;
	return $input;
}

sub extract_uids() {
    my @uids = ();
    foreach my $uidt (@_) {
        my $uid = $uidt->{'uid'};
        push(@uids, $uid);
        debug "extracted uid $uid";
    }
    return \@uids;
}

sub just_emails() {
    my @emails = ();
    foreach my $id (@_) {
        $id =~ s/.*\<(.*)\>.*/$1/;
        push(@emails, $id);
        debug "extracted email $id";
    }
    return \@emails;
}

# Ask for important information and check for restrictions

sub ask_name() {
	my $name = &user_input('Full Name (minimum 5 chars): ');
	while(length($name) < 5) {
		$name = &user_input("Name too short!\nFull Name (minimum 5 chars): ");
	}
	return $name;
}

sub ask_name_separates() {
	my $surname = &user_input('Surname: ');
	while(length($surname) == 0) {
		$surname = &user_input("Name too short!\nSurname: ");
	}
	my $name = &user_input('Given name: ');
	while(length($name) == 0) {
		$name = &user_input("Name too short!\nGiven name: ");
	}
	return ($name, $surname);
}

sub ask_pin() {
	my $pin;
	my $confirm;

	print qq[Your PIN is used to activate your smartcard each time it is used\n];
	do {
		$pin = &secure_input('PIN (minimum 6 digits, max 32): ');
		until($pin =~ /^[[:digit:]]{6,32}$/) {
			$pin = &secure_input("Invalid PIN!\nPIN (minimum 6 digits, max 32): ");
		}
		$confirm = &secure_input('Confirm: ');
		print "\nConfirmation does not match\n" unless $pin eq $confirm;

	} until($pin eq $confirm);

	return $pin;
}

sub ask_admin_pin() {
	my $pin;
	my $confirm;

	print qq[Your Admin PIN is required to update or modify your smartcard\n];
	do {
		$pin = &secure_input('Admin PIN (minimum 8 digits, max 32): ');
		until($pin =~ /^[[:digit:]]{8,32}$/) {
			$pin = &secure_input("Invalid Admin PIN!\nPIN (minimum 8 digits, max 32): ");
		}
		$confirm = &secure_input('Confirm: ');
		print "\nConfirmation does not match\n" unless $pin eq $confirm;

	} until($pin eq $confirm);

	return $pin;
}

sub ask_email() {
    my $prompt = shift;
    $prompt = 'Email address: ' unless $prompt;
	my $email;
	while (! $email) {
		$email = &user_input($prompt);
		while($email and ! Email::Valid->address($email)) {
			$email = &user_input("Not a valid email address!\nEmail address: ");
		}
	}
	return $email;
}

sub ask_expiry() {
	print qq[It is strongly recommended to set an expiry date on all PGP keys.
This ensures that lost keys will not remain valid forever. Expiry dates
can be extended retrospectively.\n\n];
	my $expiry_prompt = "Expires in (suffix d,w,m,y OR date as YYYY-MM-DD, default $default_expiry): ";
	my $expiry = &user_input($expiry_prompt);
	while($expiry !~ /^(\d+[dwmy]|\d\d\d\d-\d\d-\d\d|)$/) {
		print qq[That is not a valid expiry value\n];
		$expiry = &user_input($expiry_prompt);
	}
	$expiry = $default_expiry unless $expiry;
	return $expiry;
}

sub ask_usage() {
	my $usage_prompt = 'Subkey usage (one or more of [S]ign [E]ncrypt [A]uthenticate): ';
	my $usage = uc(&user_input($usage_prompt));
	while($usage !~ /^[SEA]+$/) {
		print qq[That is not a valid usage\n];
		$usage = &user_input($usage_prompt);
	}
	return $usage;
}

sub ask_passphrase() {
	print(q[A passphrase will be used to protect your private keys.

The passphrase should contain at least 16 characters, and at least one
non-alphanumeric character, such as punctuation.

]);
	my $passphrase;
	my $confirm;
	do {
		$passphrase = &secure_input('Key passphrase: ');
		while(
			length($passphrase) < 16 or
			! $passphrase =~ /[^[:alnum:]]/
		) {
			$passphrase = &secure_input(q[Passphrase is not strong enough.

Key passphrase: ]);
		}
		$confirm = &secure_input('Confirm: ');
		print "\nConfirmation does not match\n" unless $passphrase eq $confirm;

	} until($passphrase eq $confirm);

	return $passphrase;
}

sub ask_with_default() {
	my $prompt = shift;
	my $default = shift;

	my $input = &user_input("$prompt [$default]: ");
	$input = $default unless $input;

	return $input;
}

# Don't use print below here; this allows us to swap in a GUI routine later.

sub notify() {
    print shift . "\n";
}


##############################################################
####################### GPG harnesses ########################
##############################################################


############### Edit-key meta-harness

# This particular incantation is used in lots of places, so abstract out

sub edit_key() {
	my $key_id = shift;
	my $transcript = shift;

	# Nope, this doesn't seem to work. How do we get gpg to shut up?
	my $redirect = $CMD_OPTIONS{'debug'}?'':'>/dev/null 2>&1';

	open(my $gpg_input, '|-', "gpg $default_gpg_options --edit-key --command-fd 0 --expert $key_id $redirect")
		or die "failed to create gpg process\n";

	print $gpg_input $transcript;
	close $gpg_input;
}

sub export_key() {
    my $key_id = shift;
    my $output_file = shift;
	system("gpg $default_gpg_options --armor --export '$key_id' > $output_file") == 0
		or die "failed to export key\n";
}


############### Upload, download harnesses


sub publish() {
    my $key_id = shift;
    debug qq[publishing key $key_id];
    if($CMD_OPTIONS{'nopublish'}) {
        &notify(qq[NOPUBLISH: no data will be published, skipping]);
    } else {
        system('gpg', '--send-keys', $key_id);
    }
}

sub publish_wks() {
	my $key_id = shift;
    my $email_id = shift;
    my ($mail_server, $port) = split(':', shift);
    $port = 25 unless $port;
    my $mail_username = shift;
    my $mail_password = shift;
    debug qq[publishing key $key_id to WKS];
    if($CMD_OPTIONS{'nopublish'}) {
        &notify(qq[NOPUBLISH: no data will be published, skipping]);
        return 0;
    }

    my $transport = Email::Sender::Transport::SMTP->new(
        host=>$mail_server,
        port=>$port,
        ssl=>'starttls',
        sasl_username=>$mail_username,
        sasl_password=>$mail_password,
    );

    open(my $handle, '-|', "/usr/lib/gnupg/gpg-wks-client --create '$key_id' '$email_id'")
        or die "failed to create WKS request\n";

    try {
        Email::Sender::Simple->send(
            do { local $/; <$handle>},
            { transport=>$transport }
        );
    } catch {
        &notify(qq[Failed to publish ID "$email_id" to WKS]);
    };
    close($handle);
}

sub email_key() {
	my $key_id = shift;
    my $mail_recipient = shift;
    my ($mail_server, $port) = split(':', shift);
    $port = 25 unless $port;
    my $mail_username = shift;
    my $mail_password = shift;
    debug qq[emailing key $key_id];

    my $transport = Email::Sender::Transport::SMTP->new(
        host=>$mail_server,
        port=>$port,
        ssl=>'starttls',
        sasl_username=>$mail_username,
        sasl_password=>$mail_password,
    );

    open(my $handle, '-|', "gpg $default_gpg_options --armor --export '$key_id'")
        or die "failed to open GPG process\n";

    my $email = Email::MIME->create(
        header_str => [
            To      => $mail_recipient,
            From    => $mail_username . '@' . $mail_server,
            Subject => "PGP key from frith",
        ],
        parts => [
            q[See attached],
            Email::MIME->create(
                attributes => {
                    filename     => "${key_id}.asc",
                    content_type => "application/octet-stream",
                    name         => "${key_id}.asc",
                },
                body => do { local $/; <$handle>},
            )
        ],
    );

    try {
        Email::Sender::Simple->send(
            $email,
            { transport=>$transport }
        );

    } catch {
        &notify($_->message);
    };
    close($handle);
}

sub download_key() {
	my $key_id = shift;
	my $success;
	open(my $pipe, '-|', "gpg $default_gpg_options --command-fd 0 --recv-keys $key_id </dev/null 2>&1")
		or die "failed to create gpg process\n";
	while(<$pipe>) {
		debugpipe $_;
		if(/gpg: Total number processed: 1/) {
			$success = $key_id;
		}
	}
	close($pipe);
	return $success;
}


################ Show info harnesses

# TODO: These are ugly. Rework as per show_subkeys #48

sub display_key_info() {
	my $key_id = shift;
	system('gpg', '--list-keys', '--keyid-format', '0xlong', '--with-fingerprint', $key_id);
}

sub list_secret_keys() {
    # TODO: only show usable keys by default #49
	system('gpg', '--list-secret-keys', '--keyid-format', '0xlong', '--with-fingerprint');
}


################ Make new stuff harnesses


sub new_primarykey() {
	# Create an RSA primary key with no usages other than Certify
	# We only support RSA, for smartcard compatibility
	my $name = shift;
	my $email = shift;
	my $options = shift; # hash REFERENCE, use ->{}

	my $expiry = $options->{'expiry'};
	$expiry = $default_expiry unless $expiry;

	my $passphrase = $options->{'passphrase'}; # NEW passphrase - optional
	$passphrase = '' unless $passphrase;

	my $bits = $options->{'bits'};
	$bits = $default_bits unless $bits;

	# send the gpg output to a spool file so we can extract the fpr
	# of the new key later, otherwise we'll have no idea which key we
	# just created
	(undef, my $tempname) = tempfile();
    debug qq[saving output in temporary file $tempname];
	open(my $gpg_input, '|-', "gpg $default_gpg_options --batch --command-fd 0 --gen-key --expert >$tempname 2>&1")
		or die "failed to create gpg process\n";
	print $gpg_input qq[%echo start
Key-Type: rsa
Key-Usage: cert
Key-Length: $bits
Expire-Date: $expiry
Name-Real: $name
Name-Email: $email
Passphrase: $passphrase
%commit
%echo done
];
	close($gpg_input);

	# Now open the transcript file and extract the fingerprint.
	# We won't delete it afterwards, as it may be useful for debugging.
	my $key_id;
	open(my $logfile, '<', $tempname)
		or die("Cannot open $tempname for reading\n");
	while(<$logfile>) {
        chop;
		if(s/^\[GNUPG:\] KEY_CREATED P //) {
			$key_id = &id_filter($_);
			last;
		};
	}

    unlink $tempname unless $CMD_OPTIONS{'debug'};
	return $key_id;
}

sub new_subkey() {
	# Create an RSA subkey with a single usage
	# We only support RSA, for smartcard compatibility
	my $key_id = shift;
	my $usage = shift;
	my $passphrase = shift; # OLD passphrase - mandatory!
	my $options = shift; # hash REFERENCE, use ->{}

	my $expiry = $options->{'expiry'};
	$expiry = $default_expiry unless $expiry;

	my $bits = $options->{'bits'};
	$bits = $default_bits unless $bits;

    # quick-add-key expects a comma-separated list of usage words
    my @longusages;
    foreach my $char (split(//, $usage)) {
        push(@longusages, $usage_map{$char});
    }
	my $longusage = join(",", @longusages);
    die "could not parse usage list: $usage" unless $longusage;
    open(my $gpg_input, '|-', "gpg $default_gpg_options --quick-add-key $key_id rsa$bits $longusage $expiry")
        or die "failed to create gpg process\n";
    print $gpg_input "$passphrase\n";
    close($gpg_input);
}

sub new_uid() {
	my $key_id = shift;
	my $name = shift;
	my $email = shift;
	my $passphrase = shift;

    open(my $gpg_input, '|-', "gpg $default_gpg_options --quick-add-uid $key_id '$name <$email>'")
        or die "failed to create gpg process\n";
    print $gpg_input "$passphrase\n";
    close($gpg_input);
}


################## Extract info for further processing harnesses


# TODO: rewrite this so it returns secret key structures rather than just the
# IDs - this will save some reimplementation in other routines below. #47
sub get_secret_keys() {
	my @secret_key_ids;

	open(my $pipe, '-|', "gpg $default_gpg_options --with-colons --list-secret-keys </dev/null 2>&1")
		or die "failed to create gpg process\n";
	while(<$pipe>) {
		debugpipe $_;
		chop;
        if(/^sec:/) {
            my $line;
            my @fields;
            do {
                $line = <$pipe>;
                @fields = split(/:/, $line);
            } until($fields[0] eq 'fpr');
            my $fingerprint = $fields[9];
			push(@secret_key_ids, $fingerprint);
			debug "secret key found $fingerprint";
		}
	}
	close($pipe);
	return @secret_key_ids;
}

sub get_subkeys() {
	my $key_id = shift;
	my @subkeys;

	my $index = 0;

	open(my $pipe, '-|', "gpg $default_gpg_options --with-colons --list-secret-keys $key_id </dev/null 2>&1")
		or die "failed to create gpg process\n";
	while(<$pipe>) {
		debugpipe $_;
        if(/^ssb:/) {
            my @fields = split(/:/, $_);
            my $created = DateTime->from_epoch(epoch => $fields[5])->iso8601();
            my $expiry = '';
            $expiry = DateTime->from_epoch(epoch => $fields[6])->iso8601() if $fields[6];
            my $usage = $fields[11];
            my $trust = $fields[1];
			$index++;
            my $line;
            do {
                $line = <$pipe>;
                @fields = split(/:/, $line);
            } until($fields[0] eq 'fpr');
            my $fingerprint = $fields[9];
			my %subkey_data = (
                'id' => $fingerprint,
				'is_revoked' => ($trust eq 'r'?1:0),
                'created' => $created,
				'valid_until' => $expiry,
				'usage' => $usage,
				'index' => $index,
			);
			debug "subkey found $fingerprint $trust $created $expiry $usage";
			push(@subkeys, \%subkey_data);
		}
	}
	close($pipe);
	return @subkeys;
}

sub get_uidts() {
	my $key_id = shift;
	my @uidts;

	open(my $pipe, '-|', "gpg $default_gpg_options --with-colons --list-keys $key_id 2>&1")
		or die "failed to create gpg process\n";
    my $index = 1;
	while(<$pipe>) {
		debugpipe $_;
        my @fields = split(':');
		if($fields[0] eq 'uid') {
			my %uid_data = (
				'trust' => $fields[1],
				'index' => $index++,
				'uid' => $fields[9],
			);
			debug "uid found ${fields[9]}";
			push(@uidts, \%uid_data);
		}
	}
	close($pipe);
	return @uidts;
}

sub get_subkey_id() {
	my $key_id = shift;
	my $usage = shift;
	my $options = shift;

	my $today = &get_date;
	debug "Today's date is $today";

	my ($subkey_id, $subkey_index);
	my @subkeys = &get_subkeys($key_id);
	for my $subkey (@subkeys) {
		if($subkey->{'usage'} eq $usage and
			!$subkey->{'is_revoked'} and
			$subkey->{'valid_until'} gt $today) {
				$subkey_id = $subkey->{'id'};
				$subkey_index = $subkey->{'index'};
				# by default, return the LAST valid key of a given type
				# this is usually what we want
				# but if we want the first one, call `last`. ;-)
				last if $options->{'first'};
		}
	}

	if($options->{'by_index'}) {
		return $subkey_index;
	} else {
		return $subkey_id;
	}
}


################ Expiry harnesses

sub expire_key() {
	my $key_id = shift;
	my $expiry = shift;
	my $passphrase = shift;

    open(my $gpg_input, '|-', "gpg $default_gpg_options --quick-set-expire $key_id $expiry")
        or die "failed to create gpg process\n";
    print $gpg_input "$passphrase\n";
    close($gpg_input);
}

sub expire_all_subkeys() {
	my $key_id = shift;
	my $expiry = shift;
	my $passphrase = shift;

    open(my $gpg_input, '|-', "gpg $default_gpg_options --quick-set-expire $key_id $expiry '*'")
        or die "failed to create gpg process\n";
    print $gpg_input "$passphrase\n";
    close($gpg_input);
}

sub expire_subkey() {
	my $key_id = shift;
	my $subkey_id = shift;
	my $expiry = shift;
	my $passphrase = shift;

    open(my $gpg_input, '|-', "gpg $default_gpg_options --quick-set-expire $key_id $expiry $subkey_id")
        or die "failed to create gpg process\n";
    print $gpg_input "$passphrase\n";
    close($gpg_input);
}


################ Revocation harnesses


sub revoke_key() {
	my $key_id = shift;
	my $passphrase = shift;
	my %options = shift;

	my $reason = $options{'reason'};
	$reason = $reason_none unless $reason;
	my $dialog = $options{'dialog'};
	$dialog = '' unless $dialog;

    # TODO: use gen-revoke here instead? #51
	# gpg $default_gpg_options --gen-revoke $key_id ??

	# GPG transcript
	# key (deselect all subkeys)
	# revkey
	# confirm
	# reason
	# dialog
	# confirm
	# $passphrase
	# save

	&edit_key($key_id, qq[key
revkey
y
$reason
$dialog
y
$passphrase
save
]);
}

sub revoke_subkey() {
	my $key_id = shift;
	my $subkey_index = shift;
	my $passphrase = shift;
	my %options = shift;

	my $reason = $options{'reason'};
	$reason = $reason_none unless $reason;
	my $dialog = $options{'dialog'};
	$dialog = '' unless $dialog;

	# GPG transcript
	# key (deselect all subkeys)
	# key $subkey_index
	# revkey
	# confirm
	# $reason
	# $dialog
	# confirm
	# $passphrase
	# save

	&edit_key($key_id, qq[key
key $subkey_index
revkey
y
$reason
$dialog
y
$passphrase
save
]);
}

sub revoke_uid() {
	my $key_id = shift;
	my $uid_index = shift;
	my $passphrase = shift;
	my %options = shift;

	my $reason = $options{'reason'};
	$reason = $reason_none unless $reason;
	my $dialog = $options{'dialog'};
	$dialog = '' unless $dialog;

	# GPG transcript
	# uid $uid_index
	# revuid
	# confirm
	# $reason
	# $dialog
	# confirm
	# $passphrase
	# save

	&edit_key($key_id, qq[uid $uid_index
revuid
y
$reason
$dialog
y
$passphrase
save
]);
}


################# passphrase


sub change_pass() {
	my $key_id = shift;
	my $old_passphrase = shift;
	my $new_passphrase = shift;

	&notify(qq[\nChanging the passphrase for $key_id]);

	# GPG transcript
	# passwd
	# old_pass
	# new_pass
	# save

	&edit_key($key_id, qq[passwd
$old_passphrase
$new_passphrase
save
]);
}


################# Smartcard harnesses


sub sc_subkey_write() {
	my $key_id = shift;
	my $options = shift; # hash REF use ->{}

	# use an options hash because otherwise confusion will be inevitable
    my @subkey;
	# signing key is always in card slot 1, encrypt=2, auth=3
	$subkey[1] = $options->{'s'};
	$subkey[2] = $options->{'e'};
	$subkey[3] = $options->{'a'};

    # Which passphrase gpg expects is not indicated in the prompt.
    # We therefore track it in a state machine *scream*
    my $passphrase=$options->{'passphrase'};

    my @command_queue=("key\n", "key $subkey[1]\n", "keytocard\n", "1\n",
        "key\n", "key $subkey[2]\n", "keytocard\n", "2\n",
        "key\n", "key $subkey[3]\n", "keytocard\n", "3\n",
        "quit\n"
    );
    my $command_index=0;
    my $expect_timeout=30;

	# the "factory" is just a standard expect object
	my $exp_factory = new Expect;
	# set default behaviours on the factory before spawning
	$exp_factory->raw_pty(1);
	# fork a new expect from the factory
	my $exp = $exp_factory->spawn("gpg $default_gpg_options --batch --yes --command-fd 0 --edit-key $key_id");
	die "failed to create gpg process\n" unless $exp;

	$exp->expect($expect_timeout,

        # Fatal errors
        [
        'Cannot exec', sub{
            die "failed to create gpg process\n";
        }], [
        '^(gpg: invalid|usage:)', sub{
            die "syntax error calling gpg\n";
        }],

        [
        'GET_BOOL (keyedit\.keytocard\.use_primary|cardedit\.genkeys\.replace_key)', sub{
            my $self=shift;
            # fill your boots
            $self->send("y\n");
            exp_continue;
        }], [
        'GET_BOOL keyedit\.save\.okay', sub{
            my $self=shift;
            # saving is never okay
            $self->send("n\n");
            exp_continue;
        }], [
        'GET_LINE (keyedit\.prompt|cardedit\.genkeys\.storekeytype)', sub{
            my $self=shift;
            $self->send($command_queue[$command_index++]);
            # State machine: next passphrase prompt wants the key passphrase
            $passphrase=$options->{'passphrase'};
            exp_continue;
        }], [
        'GET_HIDDEN passphrase\.enter', sub{
            my $self=shift;
            $self->send("$passphrase\n");
            # State machine: next passphrase prompt wants the admin pin
            $passphrase=$options->{'admin_pin'};
            exp_continue;
        }],

	);

}

sub sc_factory_reset() {
	my $gpg_input;
	# test to see if gpg-agent is being used
	if(system('gpg-connect-agent /bye')==0) {
		open($gpg_input, "|gpg-connect-agent")
			or die "failed to create gpg-connect-agent process\n";
	} else {
		open($gpg_input, "|gpg-agent --server")
			or die "failed to create gpg-agent process\n";
	}

	# Factory reset transcript as suggested by Werner
	# https://lists.gnupg.org/pipermail/gnupg-users/2009-September/037414.html
	print $gpg_input qq[scd serialno
scd apdu 00 20 00 81 08 40 40 40 40 40 40 40 40
scd apdu 00 20 00 81 08 40 40 40 40 40 40 40 40
scd apdu 00 20 00 81 08 40 40 40 40 40 40 40 40
scd apdu 00 20 00 81 08 40 40 40 40 40 40 40 40
scd apdu 00 20 00 83 08 40 40 40 40 40 40 40 40
scd apdu 00 20 00 83 08 40 40 40 40 40 40 40 40
scd apdu 00 20 00 83 08 40 40 40 40 40 40 40 40
scd apdu 00 20 00 83 08 40 40 40 40 40 40 40 40
scd apdu 00 e6 00 00
scd apdu 00 44 00 00
];
	close $gpg_input;
}

sub sc_init() {
	my $options = shift; # hash ref, use ->{}

	my $def_admin = '12345678';
	my $def_pin = '123456';

	my $name = 'Mr';
	my $surname = 'Nobody';
	my $admin = $def_admin;
	my $pin = $def_pin;
	my $lang = 'en';

	$name = $options->{'name'} if $options->{'name'};
	$surname = $options->{'surname'} if $options->{'surname'};
	$pin = $options->{'pin'} if $options->{'pin'};
	$admin = $options->{'admin'} if $options->{'admin'};
	$lang = $options->{'lang'} if $options->{'lang'};

	# run gpg --card-edit in one go, otherwise we'll get prompted for the
	# pin multiple times (?????)

	open(my $gpg_input, '|-', "gpg $default_gpg_options --card-edit --command-fd 0")
		or die "Could not open gpg process\n";

	print $gpg_input qq[admin
passwd
3
$def_admin
$admin
$admin
1
$def_pin
$pin
$pin
q
name
$surname
$name
$admin
lang
$lang
quit
];

	close $gpg_input;
}


####################################################
############### User selection tools ###############
####################################################

# TODO: rewrite this so it uses get_secret_keys rather than reimplementing
# need to refactor get_secret_keys for that to be possible tho... #41
sub select_key() {
    my $prompt = shift;
    my $include_all = shift;
    my @CH_keys;

    open(my $pipe, '-|', "gpg $default_gpg_options --with-colons --list-secret-keys")
        or die "failed to create gpg process\n";
    while(<$pipe>) {
        debugpipe $_;
        chop;
        if(/^sec:/) {
            my @fields = split(/:/, $_);
            debug "Secret key found $_";
            my @created = split('T', DateTime->from_epoch(epoch => $fields[5])->iso8601());
            my @expiry = ('', '');
            @expiry = split('T', DateTime->from_epoch(epoch => $fields[6])->iso8601()) if $fields[6];
            my $expired = ($fields[1] =~ /e/);
            my $revoked = ($fields[1] =~ /r/);
            # /d/ in field 2 is deprecated, but let's test for it anyway
            my $disabled = ($fields[11] =~ /D/ || $fields[1] =~ /d/);
            next if ! $include_all && ($expired || $revoked || $disabled);

            my $line;
            do {
                $line = <$pipe>;
                @fields = split(/:/, $line);
            } until($fields[0] eq 'fpr');
            my $fingerprint = $fields[9];
            do {
                $line = <$pipe>;
                @fields = split(/:/, $line);
            } until($fields[0] eq 'uid');
            my $primuid = $fields[9];
            push(@CH_keys,
                "$fingerprint: $primuid ${created[0]} \[expires: ${expiry[0]}\]" .
                ($expired?' EXPIRED':'') .
                ($revoked?' REVOKED':'') .
                ($disabled?' DISABLED':'')
            );
        }
    }
    close($pipe);

    my $result = &make_submenu("Select key $prompt", @CH_keys);
    $result =~ s/^([a-fA-F0-9]+):.*$/$1/ if $result;

    return $result;
}

sub select_subkey() {
	my $key_id = shift;
	my $prompt = shift;
	my @CH_subkeys;

	for my $subkey (@_) {
		next if $subkey->{'is_revoked'};

		# recreate the gpg uid listing format
		my $id = $subkey->{'id'};
		my $created = $subkey->{'created'};
		my $expiry = $subkey->{'valid_until'};
		my $usage = $subkey->{'usage'};
		my $entry = "$id $created (expires $expiry) [$usage_map{$usage}]";
		push(@CH_subkeys, $entry);
	}

	my $result = &make_submenu(qq[Select subkey of $key_id $prompt], @CH_subkeys);
	if($result and $result =~ /^([a-fA-F0-9]+)\s/) {
		return $1;
	}
}

sub select_uid() {
	my $key_id = shift;
	my $prompt = shift;
    my $uidts = shift;
    my $with_all = shift;

    my $all_uids_label = "All UIDs";
    my @CH_uids;
    push(@CH_uids, $all_uids_label) if $with_all;

	for my $uidt (@$uidts) {
		# recreate the gpg uid listing format
		my $trust = $uidt->{'trust'};
		my $index = $uidt->{'index'};
		my $uid = $uidt->{'uid'};
		next unless $trust eq 'u';
		my $entry = "[$trust] ($index) $uid";
		push(@CH_uids, $entry);
	}

	my $result = &make_submenu(qq[Select UID of $key_id $prompt], @CH_uids);
    debug "uid selected ${result}";
    return (0, '') unless $result;
    if($with_all and ($result eq $all_uids_label)) {
        return (-1, $result);
    }
	if($result =~ /^\[[[:alnum:]]+\]\s+\(([[:digit:]]+)\)\s+(.*)$/) {
		# uid_index, uid
		return ($1, $2);
	}
}

sub find_public_key() {
	# Quick and dirty method - you must know the exact key ID.
	# This is probably A Good Thing, as it prevent accidents.
	my $prompt = shift;
	my $success = 0;
	my $key_id = &id_filter(&user_input("Enter LONG key ID or fingerprint $prompt: "));
	if($key_id =~ /^([a-fA-F0-9]{16}|[a-fA-F0-9]{40})$/) {
		$success = &download_key($key_id);
	} else {
		&notify(qq[That was not a valid LONG key ID or fingerprint]);
	}
	return $success;
}

# TODO: factor out `print` here, use more generic display code #52
sub list_subkeys {
	my $key_id = shift;
	print "\nSubkeys of $key_id: \n\n";
	for my $subkey (@_) {
		my $id = $subkey->{'id'};
		my $revoked = $subkey->{'is_revoked'};
		my $expiry = $subkey->{'valid_until'};
		$expiry = '          ' unless $expiry;
		my $usage = $subkey->{'usage'};
		my $status = $revoked?'REVOKED':'expires';
		print "$id ($status: $expiry) [$usage_map{$usage}]\n";
	}
	print "\n";
}

################################################################
######################### Menu actions #########################
################################################################

# Define backup and subkey export actions first, as these are required
# by &mod_hook

############### Backups

sub SR_clone_to_tails() {
	&notify(qq[
Please insert a Tails USB disk.

If you do not have one, clone this image to a blank USB now:
Applications -> Tails -> Tails Installer -> Install by Cloning

...and come back to this window when finished.
]);

	&user_input('Hit return to continue: ');
	system('tails-clone-persistent');
}
$actionmap{$LA_clone_to_tails} = \&SR_clone_to_tails;

sub SR_backup_to_file() {
	### This is ugly as sin. We should use a decent file selector library.
	my $location_prompt = 'Backup file location';
	my $location = &ask_with_default($location_prompt, $default_backup_dir);
	return 1 unless $location;
	while(! -d $location) {
		&notify(qq[That directory does not exist]);
		my $location = &ask_with_default($location_prompt, $default_backup_dir);
		return 1 unless $location;
	}
	my $filename = &ask_with_default('Filename', $default_backup_file);
	return 1 unless $filename;

	my $date = DateTime->now->iso8601;

	chdir($gpg_location);
	system('tar', 'cvf', catfile($location, $filename),
		'--exclude', 'random_seed', '.'); # don't share randomness
	&notify(qq[
Be sure to copy $location/$filename somewhere safe and private. This
file is only protected with your passphrase. Hope you made a good one!
]);
}
$actionmap{$LA_backup_to_file} = \&SR_backup_to_file;

sub SR_restore_from_file() {
	return unless &make_confirm("restore your entire PGP config from backup");

	### This is ugly as sin. We should use a decent file selector library.
	my $location_prompt = 'Backup file location';
	my $location = &ask_with_default($location_prompt, $default_backup_dir);
	return 1 unless $location;
	while(! -d $location) {
		&notify(qq[That directory does not exist]);
		my $location = &ask_with_default($location_prompt, $default_backup_dir);
		return 1 unless $location;
	}
	my $filename = &ask_with_default('Filename', $default_backup_file);
	return 1 unless $filename;
	while(! -f catfile($location, $filename)) {
		&notify(qq[That file does not exist]);
		my $filename = &ask_with_default($location_prompt, $default_backup_file);
		return 1 unless $filename;
	}

	my $date = DateTime->now->iso8601;

	# we can't rename the dir and recreate, because under tails
	# $gpg_location is a mount point
	# would love to use rmove_glob but this bug is STILL unfixed:
	# https://rt.cpan.org/Public/Bug/Display.html?id=59402
	# have to call system() yet again. *spit*

	mkdir ("$gpg_location.$date");
	system("mv $gpg_location/* $gpg_location.$date");
	chdir($gpg_location);
	system('tar', 'xvf', catfile($location, $filename));
	unlink 'random_seed' if -f 'random_seed'; # don't share randomness

	# Then sync with keyservers by first publishing and then downloading
	return unless &make_yes("resynchronise your restored keys with the keyservers");
	for my $key_id (&get_secret_keys) {
		&publish($key_id);
		&download_key($key_id);
	}
}
$actionmap{$LA_restore_from_file} = \&SR_restore_from_file;


############### Private subkeys


sub SR_subkeys_to_file() {
	my $key_id = shift;
	$key_id = &select_key('to write to file') unless $key_id;
	return 1 unless $key_id;

	&notify(qq[
Private subkeys should only be stored on a removable disk if there is no other
way to use them on your everyday machine. Please use a PGP smartcard instead:
	https://en.wikipedia.org/wiki/OpenPGP_card
]);
	return unless &make_yes("export your private subkeys to potentially insecure media");

	### This is ugly as sin. We should use a decent file selector library.
	my $location_prompt = 'Private subkey file location';
	my $location = &ask_with_default($location_prompt, $default_subkeys_dir);
	return 1 unless $location;
	while(! -d $location) {
		&notify(qq[That directory does not exist]);
		my $location = &ask_with_default($location_prompt, $default_subkeys_dir);
		return 1 unless $location;
	}

	my $filename = &ask_with_default('Filename', "$key_id$default_subkeys_suffix");
	return 1 unless $filename;

	my $path = catfile($location, $filename);
	return unless &make_yes("export your private subkeys to $path");
	system("gpg --export-secret-subkeys --armor $key_id > $path");
}
$actionmap{$LA_subkeys_to_file} = \&SR_subkeys_to_file;


############## Modification hook

# &mod_hook should be called any time the secret key is modified
# This ensures that the user is prompted to update their backups and
# subkeys.
# Some operations (such as changing key passphrases) don't affect smartcard
# operation, so we provide &backup_hook for them instead.

sub mod_hook() {
	my $key_id = shift;
	&notify(qq[
YOU SHOULD MAKE A NEW BACKUP NOW
]);
	if($using_tails) {
		&SR_clone_to_tails;
	} else {
		&SR_backup_to_file;
	}
	&notify(qq[YOU SHOULD RE-EXPORT YOUR PRIVATE SUBKEYS NOW]);
	&SR_subkeys_to_smartcard($key_id);
}

sub backup_hook() {
	my $key_id = shift;
	&notify(qq[
YOU SHOULD MAKE A NEW BACKUP NOW
]);
	if($using_tails) {
		&SR_clone_to_tails;
	} else {
		&SR_backup_to_file;
	}
}


############### Certification


sub SR_cert_scan() {
    my $mail_server = '';
    my $mail_username = '';
    my $mail_password = '';
# unlike monkeysign, monkeyscan's -u option appears to be a no-op - it
# defaults to the oldest valid key regardless and you must select the signing
# key from the dropdown. Don't prompt, so that the user isn't misled.
# TODO: put this back in once we have got rid of monkeysign/scan (#34)
#	my $my_key_id = &select_key('to certify with');
#	return 0 unless $my_key_id;

	until($mail_server) {
		$mail_server = &user_input('Mail server address (or address:port): ');
	}
	until($mail_username) {
		$mail_username = &user_input('Mail server username: ');
	}
	until($mail_password) {
		$mail_password = &secure_input('Mail server password: ');
	}

    if($using_tails) {
        system('monkeyscan', '--tor', '-s', $mail_server,
            '--smtpuser', $mail_username, '--smtppass', $mail_password)
#            '-u', $my_key_id);
    } else {
        system('monkeyscan', '-s', $mail_server,
            '--smtpuser', $mail_username, '--smtppass', $mail_password)
#            '-u', $my_key_id);
    }
}
$actionmap{$LA_cert_scan} = \&SR_cert_scan;

sub SR_cert_manual() {
    my $mail_server = '';
    my $mail_username = '';
    my $mail_password = '';
	my $my_key_id = &select_key('to certify with');
	return 0 unless $my_key_id;
	my $key_id = &find_public_key('to certify');
	return 0 unless $key_id;

	until($mail_server) {
		$mail_server = &user_input('Mail server address (or address:port): ');
	}
	until($mail_username) {
		$mail_username = &user_input('Mail server username: ');
	}
	until($mail_password) {
		$mail_password = &secure_input('Mail server password: ');
	}

    if($using_tails) {
        system('monkeysign', '--tor', '-s', $mail_server,
            '--smtpuser', $mail_username, '--smtppass', $mail_password,
            '-u', $my_key_id, '--', $key_id);
    } else {
        system('monkeysign', '-s', $mail_server,
            '--smtpuser', $mail_username, '--smtppass', $mail_password,
            '-u', $my_key_id, '--', $key_id);
    }
}
$actionmap{$LA_cert_manual} = \&SR_cert_manual;

sub SR_decert_manual() {
	my $key_id = &find_public_key('to decertify');
	if($key_id) {
		&display_key_info($key_id);
		if(&make_confirm("revoke all certification signatures on $key_id")) {
			system("gpg $default_gpg_options --batch --yes --edit-key $key_id revsig") or die "failed to create gpg process\n";
            &publish($key_id);
		}
	} else {
		&notify(qq[Key not found]);
	}
}
$actionmap{$LA_decert_manual} = \&SR_decert_manual;


############### Generation


sub SR_usedefaults() {
	my $name = &ask_name;
	my $email = &ask_email;
    unless($email) {
        return 0 unless &make_confirm('create a key with a blank email address');
    }
	my $passphrase = &ask_passphrase;
	my $expiry = &ask_expiry;

	unless(&first_time) {
		return 0 unless &make_confirm("create an additional primary key on a non-empty keyring");
	}

	&notify(qq[
Name: $name
Email: $email
Expiry date: $expiry
]);

	return 0 unless &make_yes('create a new primary key with the above details');
	my $key_id = &new_primarykey($name, $email, {'expiry'=>$expiry, 'passphrase'=>$passphrase});

	die("Key fingerprint not found in gpg transcript - panic!\n") unless $key_id;

	&new_subkey($key_id, 's', $passphrase, {'expiry'=>$expiry});
	&new_subkey($key_id, 'e', $passphrase, {'expiry'=>$expiry});
	&new_subkey($key_id, 'a', $passphrase, {'expiry'=>$expiry});
	&mod_hook($key_id);
	if(&make_yes(qq[publish key $key_id])) {
		&publish($key_id);
	}
}
$actionmap{$LA_usedefaults} = \&SR_usedefaults;

sub SR_gen_advanced() {
	&notify("Type 'help' for help, ctrl-c to return to menu");
	system('gpg', '--gen-key', '--with-fingerprint', '--expert');
}
$actionmap{$LA_gen_advanced} = \&SR_gen_advanced;


############### Publication


sub SR_publish_to_keyserver() {
    my $key_id = &select_key('to publish to the keyserver(s)');
    return 0 unless $key_id;
    if(&make_yes(qq[publish key $key_id])) {
        &publish($key_id);
    }
}
$actionmap{$LA_publish_to_keyserver} = \&SR_publish_to_keyserver;

sub SR_publish_to_wks() {
    my $email_ids; # array ref
    my $mail_server = '';
    my $mail_username = '';
    my $mail_password = '';
    my $key_id = &select_key('to publish to the Web Key Directory');
    return 0 unless $key_id;

    my @uidts = &get_uidts($key_id);
    my ($uid_index, $uid) = &select_uid($key_id, 'to publish', \@uidts, 'with_all');
    debug "$uid_index, $uid";
    return 0 unless $uid;
    if($uid_index == -1) {
        return 0 unless &make_yes(qq[publish all UIDs on $key_id]);
        my $full_uids = &extract_uids(@uidts);
        $email_ids = &just_emails(@$full_uids);
    } else {
        $email_ids = &just_emails($uid);
    }
    debug "uids " . join(',', @$email_ids);
    until($mail_server) {
        $mail_server = &user_input('Mail server address (or address:port): ');
    }
    until($mail_username) {
        $mail_username = &user_input('Mail server username: ');
    }
    until($mail_password) {
        $mail_password = &secure_input('Mail server password: ');
    }
    if(&make_yes(qq[publish key $key_id to the Web Key Directory])) {
        foreach my $email_id (@$email_ids) {
            &publish_wks($key_id, $email_id, $mail_server, $mail_username, $mail_password);
        }
        &notify(qq[Key submitted. Please check your email inbox(es) for further instructions]);
    }
}
$actionmap{$LA_publish_to_wks} = \&SR_publish_to_wks;

sub SR_send_by_email() {
    my $mail_recipient = '';
    my $mail_server = '';
    my $mail_username = '';
    my $mail_password = '';
    my $key_id = &select_key('to send via email');
    return 0 unless $key_id;
    until($mail_recipient) {
        $mail_recipient = &ask_email('Recipient address: ');
    }
    until($mail_server) {
        $mail_server = &user_input('Mail server address (or address:port): ');
    }
    until($mail_username) {
        $mail_username = &user_input('Mail server username: ');
    }
    until($mail_password){
        $mail_password = &secure_input('Mail server password: ');
    }
    if(&make_yes(qq[email key $key_id to $mail_recipient])) {
        &email_key($key_id, $mail_recipient, $mail_server, $mail_username, $mail_password);
    }
}
$actionmap{$LA_send_by_email} = \&SR_send_by_email;

sub SR_save_to_file() {
    my $key_id = &select_key('to export');
    my $output_file = catfile(home(), "${key_id}.asc");
    &export_key($key_id, $output_file);
    &notify(qq[Key written to $output_file]);
}
$actionmap{$LA_save_to_file} = \&SR_save_to_file;


############### Smartcard


sub SR_sc_status() {
	while(! &detect_smartcard) {
		return 0 unless &prompt_insert_sc;
	}

	system('gpg', '--card-status');
}
$actionmap{$LA_sc_status} = \&SR_sc_status;

sub SR_sc_factory_reset() {
	return 1 unless &make_confirm("reset your v2.x PGP smartcard to factory default (THIS WILL BRICK A v1.x CARD)");

	while(! &detect_smartcard) {
		return 0 unless &prompt_insert_sc;
	}
	&sc_factory_reset;

	&notify(qq[Please remove the card and reinsert...]);
	# Sometimes this goes a little screwy.
	while(&detect_smartcard) {}
	while(! &detect_smartcard) {}
	&notify("OK");
}
$actionmap{$LA_sc_factory_reset} = \&SR_sc_factory_reset;

sub SR_init_smartcard() {
	while(! &detect_smartcard) {
		return 0 unless &prompt_insert_sc;
	}

	if(! $fresh_smartcard) {
		# prompt user to see if they're sure they want to continue
		return 0 unless &prompt_overwrite_old_sc;

		# reset to factory because we need to know default admin pin
		# use menu subroutine so that user gets prompted
		&SR_sc_factory_reset;
	}

	my ($name, $surname) = &ask_name_separates;
	my $pin = &ask_pin;
	my $admin = &ask_admin_pin;

	&sc_init({'name' => $name, 'surname' => $surname, 'pin' => $pin, 'admin' => $admin});

	# now show the user what they just did
	&SR_sc_status;
}
$actionmap{$LA_init_smartcard} = \&SR_init_smartcard;

sub SR_subkeys_to_smartcard() {
	my $key_id = shift;
	while(! &detect_smartcard) {
		return 0 unless &prompt_insert_sc;
	}
	if($fresh_smartcard) {
		# initialise the smartcard
		&SR_init_smartcard;
	} else {
#		# prompt user to see if they're sure they want to continue
#		return 0 unless &prompt_overwrite_old_sc;
	}
	$key_id = &select_key('to write to smartcard') unless $key_id;

	# Now get the indexes (NOT IDs!) of each valid subkey
	my $subkey_s = &get_subkey_id($key_id, 's', {'by_index' => 1});
	my $subkey_e = &get_subkey_id($key_id, 'e', {'by_index' => 1});
	my $subkey_a = &get_subkey_id($key_id, 'a', {'by_index' => 1});
	my $admin = &secure_input("Smartcard admin pin: ");
	my $passphrase = &secure_input("Key passphrase: ");

	&sc_subkey_write($key_id,
        {'admin_pin' => $admin, 'passphrase' => $passphrase,
		's' => $subkey_s, 'e' => $subkey_e, 'a'=> $subkey_a});
}
$actionmap{$LA_subkeys_to_smartcard} = \&SR_subkeys_to_smartcard;

sub SR_sc_pin() {
	while(! &detect_smartcard) {
		return 0 unless &prompt_insert_sc;
	}
	system('gpg', '--change-pin');
}
$actionmap{$LA_sc_pin} = \&SR_sc_pin;

# Not immediately necessary
#sub SR_sc_name() { # TODO #44
#	while(! &detect_smartcard) {
#		return 0 unless &prompt_insert_sc;
#	}
#	print qq[ run gpg --card-edit\n\n];
#}
#$actionmap{$LA_sc_name} = \&SR_sc_name;

# Not immediately necessary
#sub SR_sc_lang() { # TODO #45
#	while(! &detect_smartcard) {
#		return 0 unless &prompt_insert_sc;
#	}
#	print qq[ run gpg --card-edit\n\n];
#}
#$actionmap{$LA_sc_lang} = \&SR_sc_lang;

# Not immediately necessary
#sub SR_sc_keylocation() { # TODO #46
#	while(! &detect_smartcard) {
#		return 0 unless &prompt_insert_sc;
#	}
#	print qq[ run gpg --card-edit\n\n];
#}
#$actionmap{$LA_sc_keylocation} = \&SR_sc_keylocation;

sub SR_smartcard_advanced() {
	while(! &detect_smartcard) {
		return 0 unless &prompt_insert_sc;
	}
	&notify("Type 'help' for help, 'quit' to return to menu");
	system('gpg', '--card-edit', '--with-fingerprint', '--expert');
}
$actionmap{$LA_smartcard_advanced} = \&SR_smartcard_advanced;


############### Key info


sub SR_key_passphrase() {
	my $key_id = &select_key('to change passphrase for');
	return 0 unless $key_id;
	my $old_passphrase = &secure_input('Old passphrase: ');
	# TODO: We really should test the old passphrase before continuing...!
	my $new_passphrase = &ask_passphrase;
	&change_pass($key_id, $old_passphrase, $new_passphrase);
    # Backup only, don't re-export unnecessarily to smartcard
	&backup_hook($key_id);
}
$actionmap{$LA_key_passphrase} = \&SR_key_passphrase;

sub SR_new_uid() {
	my $key_id = &select_key('to add new UID to');
	return 0 unless $key_id;
	my $name = &ask_name;
	my $email = &ask_email;
    unless($email) {
        return 0 unless &make_confirm('create a UID with a blank email address');
    }
	if(&make_yes(qq[add the UID '$name <$email>' to $key_id])) {
		my $passphrase = &secure_input('Key passphrase: ');
		&new_uid($key_id, $name, $email, $passphrase);
		if(&make_yes(qq[republish key $key_id])) {
			&publish($key_id);
		}
	}
}
$actionmap{$LA_new_uid} = \&SR_new_uid;

sub SR_revoke_uid() {
	my $key_id = &select_key('to revoke UID from');
	return 0 unless $key_id;
	my @uidts = &get_uidts($key_id);
	if ((scalar @uidts) > 1) {
		my ($uid_index, $uid) = &select_uid($key_id, 'to revoke', \@uidts);
		return 0 unless $uid;
		if(&make_yes(qq[revoke the UID '$uid' on $key_id])) {
			my $passphrase = &secure_input('Key passphrase: ');
			&revoke_uid($key_id, $uid_index, $passphrase);
			if(&make_yes(qq[republish key $key_id])) {
				&publish($key_id);
			}
		}
	} else {
		&notify(qq[
Cannot revoke the last UID on $key_id
You must create a new UID first
]);
	}
}
$actionmap{$LA_revoke_uid} = \&SR_revoke_uid;

sub SR_expire_key() {
	my $key_id = &select_key('to change expiry', 'include_all');
	return 0 unless $key_id;
	my $expiry = &ask_expiry;
	return 0 unless &make_yes("change the expiry on $key_id to $expiry");
	my $passphrase = &secure_input('Key passphrase: ');
	&expire_key($key_id, $expiry, $passphrase);
	if(&make_yes("change the expiry on all subkeys of $key_id to $expiry")) {
        &expire_all_subkeys($key_id, $expiry, $passphrase);
    }
	if(&make_yes(qq[republish key $key_id])) {
		&publish($key_id);
	}
	return 1;
}
$actionmap{$LA_expire_key} = \&SR_expire_key;

sub SR_new_subkey() {
	my $key_id = &select_key('to to add subkey to');
	return 0 unless $key_id;
	&list_subkeys($key_id, &get_subkeys($key_id));
	my $usage = &ask_usage;
	my $expiry = &ask_expiry;
	my $passphrase = &secure_input('Key passphrase: ');
	&new_subkey($key_id, $usage, $passphrase, {'expiry'=>$expiry});
	&mod_hook($key_id);
	if(&make_yes(qq[republish key $key_id])) {
		&publish($key_id);
	}
}
$actionmap{$LA_new_subkey} = \&SR_new_subkey;

sub SR_expire_subkey() {
	my $key_id = &select_key('with subkey to change expiry');
	return 0 unless $key_id;

	my @subkeys = &get_subkeys($key_id);
	my $subkey_id = &select_subkey($key_id, 'to change expiry', @subkeys);
	return 0 unless $subkey_id;

	my $expiry = &ask_expiry;
	my $passphrase = &secure_input('Key passphrase: ');

	&expire_subkey($key_id, $subkey_id, $expiry, $passphrase);
	if(&make_yes(qq[republish key $key_id])) {
		&publish($key_id);
	}
}
$actionmap{$LA_expire_subkey} = \&SR_expire_subkey;

sub SR_key_advanced() {
	my $key_id = &select_key('to edit', 'include_all');
	return 0 unless $key_id;
	&notify("Type 'help' for help, 'quit' to return to menu");
	system('gpg', '--edit-key', '--with-fingerprint', '--expert', $key_id);
}
$actionmap{$LA_key_advanced} = \&SR_key_advanced;


############## Revocation


sub SR_revoke_subkey() {
	debug qq[revoke specific subkey and optionally create a new one];
	my $key_id = &select_key('with subkey to revoke');
	return 0 unless $key_id;

	my @subkeys = &get_subkeys($key_id);
	my $subkey_id = &select_subkey($key_id, 'to revoke', @subkeys);
	return 0 unless $subkey_id;

    my $subkey_index = 0;
    my $subkey;
    while($subkeys[$subkey_index]) {
        $subkey = $subkeys[$subkey_index];
        last if($subkeys[$subkey_index]->{'id'} == $subkey_id);
        $subkey_index++;
    }

	return 0 unless &make_confirm(qq[revoke the subkey ${subkey_id} on key ${key_id}]);
	my $passphrase = &secure_input('Key passphrase: ');

	die qq[ERROR revoking subkey $subkey_id on $key_id - panic!\n]
		unless &revoke_subkey($key_id, $subkey_id, $passphrase);
	&notify(qq[REVOKED SUBKEY ${subkey_id}]);

	my $usage = $subkey->{'usage'};
	if(&make_yes(qq[generate a replacement $usage subkey on $key_id])) {
		my $expiry = $subkey->{'expiry'};
		&new_subkey($key_id, $usage, $passphrase, {'expiry'=>$expiry});
		&mod_hook($key_id);
	}
	if(&make_yes(qq[republish key $key_id])) {
		&publish($key_id);
	}
}
$actionmap{$LA_revoke_subkey} = \&SR_revoke_subkey;

sub SR_revoke_primary() {
	debug qq[the big one. choose a primary key and nuke it];
	my $key_id = &select_key('to revoke');
	return 0 unless &make_confirm(qq[revoke the key ${key_id}]);
	my $passphrase = &secure_input('Key passphrase: ');

	die qq[ERROR revoking key $key_id - panic!\n]
		unless &revoke_key($key_id, $passphrase);
	&notify(qq[REVOKED KEY ${key_id}]);

	if(&make_confirm(qq[PERMANENTLY publish the revocation of $key_id?])) {
		&publish($key_id);
	} else {
		&notify(qq[IN ORDER TO CONTINUE USING THIS KEY YOU MUST RESTORE FROM BACKUP]);
		&SR_restore_from_file;
	}
}
$actionmap{$LA_revoke_primary} = \&SR_revoke_primary;


############### Help


sub SR_getting_started() {
	my $response;
	$response = &make_submenu('GETTING STARTED', @CH_getting_started);
	return unless $response;
	&evaluate_choice($response);
}
$actionmap{$LA_getting_started} = \&SR_getting_started;


sub SR_manual() {
	system ('clear');
	&notify(qq[
${program} is a utility to simplify the best practice use of GnuPG
encryption keys. It is intended to be used OFFLINE with the aid of a
Tails bootable flash drive (https://tails.boum.org). You can still use
it with other operating systems, but a) you negate many of the security
benefits and b) it will complain accordingly every time it starts. To
install on Tails, follow the instructions at the project homepage:
	https://andrewg.com/frith.html

${program} has several command line debugging options available
(run `${program} --help` for a list), but the only one you are likely
to use is `--nopublish`, which suppresses any communication with the
outside world, allowing you to create temporary keys for test purposes
without fear of them getting pushed to the keyservers.

${program} is menu-driven. There is no batch processing interface, as
all operations are performed using the batch interfaces of other
programs, such as gnupg, monkeysphere and openssh-client. There is
currently some noise emitted from gnupg's batch interface when carrying
out certain operations - this is expected, if ugly. I'm working on it...
]);
	return unless &make_pause();
	system('clear');
	&notify(qq[
${program} manages your GnuPG private keys by offering the following
services:

* Creation, expiry and revocation of keys, subkeys and IDs
* Export of private subkeys to removable media, e.g. PGP smartcard
* Certification of other people's keys (web of trust)
* Upload of public keys to keyservers (requires a network connection)
* Backup and restore to/from secondary media

It is strongly recommended to use a PGP smartcard for everyday use.
These store private subkeys in non-retrievable storage and perform
decryption and signing operations in a tamper-proof processor on the
card itself. You can thereby use your subkeys as normal (with a few
caveats, see next page) on a laptop or desktop computer without ever
storing private key material on that computer.

If you do not have a PGP smartcard, or if your device/software does not
support smartcard use, private subkeys can be exported in encrypted form
and saved to a removable drive. This is obviously less secure, and
should only be done if absolutely necessary.
]);
	return unless &make_pause();
	system('clear');
	&notify(qq[
Exporting your primary private key is NOT supported. This key is used
to confirm your identity and the validity of your subkeys. Unlike your
subkeys, it cannot be easily revoked or replaced in case of compromise,
and so it is strongly recommended that the primary private key does not
leave the Tails environment.

Certain operations can thus only ever be performed inside Tails:

* Creating, revoking and changing the expiry of keys, subkeys and IDs
* Certification of other people's keys (web of trust)

This is because each of these operations requires a fresh signature to
be created by the primary private key. If you wish to run ${program}
on a non-Tails environment this restriction does not apply, BUT you lose
the extra security of keeping your primary private key stored offline.
]);
	return unless &make_pause();
	system('clear');
	&notify(qq[
For most users, the Getting Started Wizard should be sufficient to get
you up and running, so long as you have the following to hand:

* A computer that can boot from USB flash, with two USB ports spare
* Two flash drives, at least one with Tails and ${program} installed
	(8GB recommended)
* A removable device to store your private subkeys
	(PGP smartcard recommended, or a third flash drive in a pinch)

You will be prompted to insert the second Tails drive to create a
backup before exporting your private subkeys to a removable device. This
backup should be stored in a safe remote location (such as a relative's
house) and is equivalent to the original. You only need to make a fresh
backup after creating new keys or subkeys - everything else can be
generated again from the info in the public key.
]);
	return unless &make_pause();
	system('clear');
	&notify(qq[
For further information, check the project homepage at
https://andrewg.com/frith.html
]);
}
$actionmap{$LA_manual} = \&SR_manual;


########################## Main ################################

# Lights, camera, action.

sub main() {
	&parse_options;

	system ('clear') unless $CMD_OPTIONS{'debug'};
	&notify("This is ${program} v${version}");

	if($CMD_OPTIONS{'help'}) {
		&option_help;
		exit 0;
	}

	if($CMD_OPTIONS{'nopublish'}) {
		&notify("NOPUBLISH: keys will not be published");
	}

	&tails_test;
	if($using_tails) {
		&notify("Tails detected");
		if(! $using_tails_persistence) {
			&notify("${program} on tails requires persistence");
			# TODO: create or mount persistent volume
			exit;
			&tails_test;
		}
		if(! $using_tails_persistence_gpg) {
			&notify("${program} on tails requires persistent GPG");
			# TODO: configure for gpg
			exit;
			$using_tails_persistence_gpg = 1;
		}
	} else {
		&notify(qq[
${program} is intended to be run from inside a tails live system. While
it will work on any computer, you will not benefit from all the security
features it provides, such as offline storage of your primary key.
]);
		exit unless &make_warned;
		# Disable tor
		IO::Socket::Socks::Wrapper->import(0);
	}

	if(&first_time()){
		&notify(qq[This appears to be the first time you have run ${program}]);
		&SR_getting_started;
	} else {
		if(&make_yes('refresh your public key(s) from the keyservers')) {
			foreach my $key_id (&get_secret_keys) {
				&download_key($key_id);
			}
		}
	}

	# top level menu
	for (;;) {
		system ('clear') unless $CMD_OPTIONS{'debug'};
		&notify("This is ${program} v${version}");
		&list_secret_keys;

		my $response = $menu->choose(
			[@CH_top, undef],
			{
				prompt => "MAIN MENU\n\n",
				undef  => 'Exit',
				layout => 3,
			}
		);
		exit unless $response;

		# each entry is a submenu
		my $subresponse = '';
		for(;;) {
			switch ($response) {
				case ($LA_certify) {
					$subresponse = &make_submenu($LA_certify, @CH_certify);
				}
				case ($LA_generate) {
					$subresponse = &make_submenu($LA_generate, @CH_generate);
				}
				case ($LA_backup) {
					if($using_tails) {
						$subresponse = &make_submenu($LA_backup, @CH_backup);
					} else {
						$subresponse = &make_submenu($LA_backup, @CH_backup_no_tails);
					}
				}
				case ($LA_publish) {
					$subresponse = &make_submenu($LA_publish, @CH_publish);
				}
				case ($LA_subkeys) {
					$subresponse = &make_submenu($LA_subkeys, @CH_subkeys);
				}
				case ($LA_smartcard) {
					$subresponse = &make_submenu($LA_smartcard, @CH_smartcard);
				}
				case ($LA_modify) {
					$subresponse = &make_submenu($LA_modify, @CH_modify);
				}
				case ($LA_help) {
					$subresponse = &make_submenu($LA_help, @CH_help);
				}
			}

			last unless $subresponse;
			&evaluate_choice($subresponse);
			&user_input('Hit enter to return to menu: ');
		}
	}
}

main();
